<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>株式評価ミニ</title>
  <style>
    :root{--fg:#0f172a;--muted:#64748b;--bg:#f8fafc;--line:#e2e8f0;}
    html,body{height:100%}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;color:var(--fg);background:linear-gradient(#fff,var(--bg))}
    .wrap{max-width:1200px;margin:32px auto;padding:0 16px}
    h1{font-size:28px;margin:0 0 16px}
    .card{background:#fff;border:1px solid var(--line);border-radius:14px;box-shadow:0 6px 20px rgba(2,6,23,.06);padding:16px}
    .row{display:grid;grid-template-columns:1fr 1fr;gap:14px}
    .row3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:14px}
    .twocol{display:grid;grid-template-columns:1.1fr .9fr;gap:16px}
    .label{font-size:12px;color:var(--muted);margin-bottom:6px}
    input{width:100%;box-sizing:border-box;padding:10px 12px;border:1px solid var(--line);border-radius:10px;background:#fff;font-size:14px}
    input.disabled{background:#f8fafc;color:#64748b}
    .grid5{display:grid;grid-template-columns:repeat(5,1fr);gap:10px}
    .grid5-head{display:grid;grid-template-columns:repeat(5,1fr);gap:10px;margin:6px 0 4px}
    .grid5-head div{font-size:12px;color:var(--muted);text-align:center}
    .log{white-space:pre-wrap;font-family:ui-monospace,Menlo,Consolas,monospace;background:#0b1020;color:#e5e7eb;border-radius:10px;padding:12px;line-height:1.5}
    .kpi{display:grid;grid-template-columns:repeat(3,1fr);gap:10px}
    .box{background:#fff;border:1px solid var(--line);border-radius:12px;padding:10px}
    .box b{font-size:22px}
    .pill{padding:2px 8px;border-radius:999px;color:#fff;font-weight:600}
    .pill.great{background:#065f46}.pill.good{background:#34d399}.pill.neu{background:#f59e0b}.pill.sell{background:#dc2626}
    .list{display:flex;flex-direction:column;gap:8px;max-height:1000px;overflow:auto}
    .rowitem{display:grid;grid-template-columns:1.6fr .9fr .7fr .8fr;gap:10px;align-items:center;border:1px solid var(--line);border-radius:10px;padding:8px 10px;cursor:pointer;background:#fff}
    .rowitem:hover{background:#f1f5f9}
    .muted{color:#64748b;font-size:12px}
    .hdr{display:grid;grid-template-columns:1.6fr .9fr .7fr .8fr;gap:10px;margin:4px 0 8px;font-size:12px;color:#64748b}
    .searchrow{display:grid;grid-template-columns:1fr;gap:12px}
    .tag{font-size:12px;color:#475569;background:#e2e8f0;border-radius:8px;padding:2px 6px}
    .small{font-size:12px;color:#64748b;word-break:break-all}
    .headrow{display:flex;align-items:center;gap:10px;justify-content:space-between}
    .headrow h2{font-size:18px;margin:0;color:#0f172a}
    .headline{font-size:24px;font-weight:800}
  </style>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin defer></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin defer></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js" defer></script>
</head>
<body>
  <div id="app" class="wrap">読み込み中…</div>

  <script>
  (function boot(){
    if(!window.React||!window.ReactDOM||!window.XLSX){return setTimeout(boot,10);}
    const React=window.React, ReactDOM=window.ReactDOM, XLSX=window.XLSX;
    const h=React.createElement;

    const asArr=v=>Array.isArray(v)?v:[], clamp=(x,a=0,b=100)=>Math.max(a,Math.min(b,x));
    const pretty=n=>Number.isFinite(n)?n.toLocaleString():"-";
    const prettyPct=x=>Number.isFinite(x)?(x>=0?"+":"")+x.toFixed(2)+"%":"-";
    const toNum=v=>{ if(v==null||v==="") return 0; if(typeof v==="number") return v; const s=String(v).replace(/[, \u3000]/g,""); const m=s.match(/^([-+]?\d+(\.\d+)?)/); return m? Number(m[1]):0; };
    const parsePercentCell=v=>{ if(v==null||v==="") return 0; if(typeof v==="number"){ return Math.abs(v)<=1? v*100 : v; } const s=String(v).trim(); if(s.endsWith("%")) return toNum(s.replace("%","")); const n=toNum(s); return Math.abs(n)<=1? n*100 : n; };
    const mean=a=>a.length? a.reduce((s,v)=>s+v,0)/a.length:0;
    const stdev=a=>{ const m=mean(a); const v=a.length? a.reduce((s,v)=>s+(v-m)**2,0)/a.length:0; return Math.sqrt(v); };
    const linreg=arr=>{ const y=asArr(arr).map(v=>Number(v)||0); const n=y.length; if(n<2) return {slope:0,intercept:0,se:0}; const x=Array.from({length:n},(_,i)=>i+1); const mx=x.reduce((a,b)=>a+b,0)/n, my=y.reduce((a,b)=>a+b,0)/n; const num=x.reduce((s,xi,i)=>s+(xi-mx)*(y[i]-my),0); const den=x.reduce((s,xi)=>s+(xi-mx)*(xi-mx),0); const slope=den===0?0:num/den, intercept=my-slope*mx; const residuals=y.map((yi,i)=> yi-(slope*x[i]+intercept)); const se=Math.sqrt(residuals.reduce((a,b)=>a+b*b,0)/Math.max(1,n-2)); return {slope,intercept,se}; };
    function smoothLogistic(z, mid, half, k){ return mid + half * (2 / (1 + Math.exp(-k * z)) - 1); }
    function median(a){ const b=[].concat(a||[]).sort((x,y)=>x-y); const n=b.length; return n? (n%2? b[(n-1)/2] : 0.5*(b[n/2-1]+b[n/2])):0; }
    function mad(a){ const m=median(a); const d=(a||[]).map(x=>Math.abs(x-m)); return median(d)||1e-9; }
    function percentileOfSorted(sorted, x){ let lo=0, hi=sorted.length; while(lo<hi){ const mid=(lo+hi>>1); if(sorted[mid]<x) lo=mid+1; else hi=mid; } return sorted.length? lo/Math.max(1,sorted.length):0.5; }
    function logit(p){ const e=1e-6; const q=Math.min(1-e, Math.max(e,p)); return Math.log(q/(1-q)); }
    function zRobust(x, med, madVal, sorted){ if(madVal<1e-8 && sorted){ return logit(percentileOfSorted(sorted, x)); } return (x - med) / (1.4826*Math.max(1e-9, madVal)); }

    const sleep=ms=>new Promise(r=>setTimeout(r,ms)), jitter=(b=140)=> b + Math.floor(Math.random()*180);
    const qCache=new Map(), TTL=5*60*1000;

    async function fetchHosted(tk){
      const r=await fetch(`https://stock-quote-api-opal.vercel.app/api/quote?ticker=${encodeURIComponent(tk)}`);
      if(!r.ok) throw new Error("hosted");
      const j=await r.json(); const px=Number(j.price ?? j.c ?? j.close);
      if(!Number.isFinite(px)) throw new Error("no price");
      return {price:px,source:`api(${j.source||"hosted"})`};
    }
    async function fetchYahoo(tk){
      const r=await fetch(`https://query1.finance.yahoo.com/v7/finance/quote?symbols=${encodeURIComponent(tk)}`,{mode:"cors"});
      if(!r.ok) throw new Error("yahoo");
      const j=await r.json(); const q=j?.quoteResponse?.result?.[0];
      const px=Number(q?.regularMarketPrice ?? q?.postMarketPrice ?? q?.preMarketPrice ?? q?.regularMarketPreviousClose);
      if(!Number.isFinite(px)) throw new Error("no price");
      return {price:px,source:"yahoo"};
    }
    async function fetchStooq(tk){
      let s=tk.toLowerCase(); if(s.endsWith(".t")) s=s.replace(/\.t$/,".jp");
      const r=await fetch(`https://stooq.com/q/l/?s=${encodeURIComponent(s)}&f=sd2t2ohlcv&h&e=csv`,{mode:"cors"});
      if(!r.ok) throw new Error("stooq");
      const t=await r.text(); const lines=t.trim().split(/\r?\n/);
      if(lines.length<2) throw new Error("no row");
      const head=lines[0].split(","), row=lines[1].split(",");
      const idx=head.findIndex(h=>h.toLowerCase()==="close");
      const px=Number(row[idx>=0?idx:row.length-2]);
      if(!Number.isFinite(px)) throw new Error("no price");
      return {price:px,source:"stooq"};
    }
    async function fetchQuoteRobust(ticker){
      if(!ticker) return {price:null,source:null};
      const tk=(ticker||"").trim(), key=tk.toLowerCase(), now=Date.now();
      const hit=qCache.get(key); if(hit && now-hit.at<TTL) return {price:hit.price,source:hit.source+" (cache)"};
      const fetchers=[fetchHosted,fetchYahoo,fetchStooq], maxRetry=3;
      for(let a=0;a<maxRetry;a++){
        for(const f of fetchers){
          try{
            const res=await f(tk);
            qCache.set(key,{...res,at:Date.now()});
            return res;
          }catch(_){}
        }
        await sleep(250*Math.pow(1.6,a)+jitter());
      }
      return {price:null,source:null};
    }

    const GH_OWNER="Tetsu1000", GH_REPO="stock_ev", GH_BRANCH="main";
    const URL_JSDELIVR=`https://cdn.jsdelivr.net/gh/${GH_OWNER}/${GH_REPO}@${GH_BRANCH}/dataset.xlsx`;
    const URL_RAW     =`https://raw.githubusercontent.com/${GH_OWNER}/${GH_REPO}/${GH_BRANCH}/dataset.xlsx`;

    function getOverrideDataURL(){ try{ const u=new URL(window.location.href); const q=u.searchParams.get("data"); return q && q.trim()? q.trim():null; }catch(_){ return null; } }
    function buster(u){ const sep=u.includes("?")?"&":"?"; return u+sep+"_="+Date.now(); }
    async function fetchArrayBufferWithFallback(urls){
      let lastErr=null;
      for(const url of urls){
        try{
          const res=await fetch(url,{mode:"cors",credentials:"omit",redirect:"follow"});
          if(!res.ok) throw new Error("fetch failed: "+res.status);
          return await res.arrayBuffer();
        }catch(err){ lastErr=err; }
      }
      throw lastErr || new Error("fetch failed");
    }

    function parseWorkbookToRows(buf, years){
      const wb=XLSX.read(buf,{type:"array"});
      const wsName=wb.SheetNames.includes("information")?"information":wb.SheetNames[0];
      const ws=wb.Sheets[wsName];
      const json=XLSX.utils.sheet_to_json(ws,{defval:null});
      const rows=(Array.isArray(json)?json:[]).map((r,idx)=>{
        const g=(k,...alts)=> r[k]!=null? r[k] : (alts.find(a=>r[a]!=null) ? r[alts.find(a=>r[a]!=null)] : null);
        const getOp = y=> toNum(g(`Op_${y}`,`OP_${y}`));
        const getFcf= y=> toNum(g(`FCF_${y}`));
        const getRoe= y=> parsePercentCell(g(`ROE_${y}`));
        const industry = g("industry","Industry","業種");
        const shareOku = toNum(g("share","Shares_Oku","share_oku"));
        const opNow = toNum(g("Op_2026","OP_2026","OP_now","今期OP予想"));
        const opNext= toNum(g("Op_2027","OP_2027","OP_next","来期OP予想"));
        const perVal= toNum(g("PER","per"));
        const pbrVal= toNum(g("PBR","pbr"));
        return {
          id:idx+1,
          name: g("company","Company")||"",
          ticker: String(g("ticker","Ticker")||""),
          industry: industry || "",
          op: years.map(getOp),
          fcf: years.map(getFcf),
          roe: years.map(getRoe),
          sharesOku: Number(shareOku)||0,
          price: Number(toNum(g("price","Price")))||null,
          opNowEst: opNow||0,
          opNextEst: opNext||0,
          per: Number.isFinite(perVal)? perVal : null,
          pbr: Number.isFinite(pbrVal)? pbrVal : null
        };
      }).filter(r=>(r.name||"").trim()!=="");
      return {rows,wsName};
    }

    async function loadDatasetFromURL(urlOrNull, years, setDataset, appendLog, fillFromRow){
      const custom=urlOrNull && urlOrNull.trim();
      const urls = custom ? [buster(custom)] : [buster(URL_JSDELIVR), buster(URL_RAW)];
      appendLog("loading from URL:\n" + (custom || URL_JSDELIVR + " → fallback raw"));
      const buf = await fetchArrayBufferWithFallback(urls);
      const {rows,wsName}=parseWorkbookToRows(buf, years);
      setDataset(rows);
      appendLog(`URL loaded: ${wsName} / ${rows.length} rows`);
      if(rows.length){
        const a=rows[0];
        appendLog(`→ 初期反映: ${a.name} (${a.ticker}) / 業種=${a.industry}`);
        fillFromRow(a,true);
      }
    }

    function App(){
      const years=[2021,2022,2023,2024,2025];

      const [name,setName]=React.useState("");
      const [ticker,setTicker]=React.useState("7203.T");
      const [industry,setIndustry]=React.useState("");
      const [price,setPrice]=React.useState(0);
      const [sharesOku,setSharesOku]=React.useState(0);
      const [per,setPer]=React.useState(null);
      const [pbr,setPbr]=React.useState(null);
      const [op,setOp]=React.useState([0,0,0,0,0]);
      const [fcf,setFcf]=React.useState([0,0,0,0,0]);
      const [roe,setRoe]=React.useState([0,0,0,0,0]);
      const [opNowEst,setOpNowEst]=React.useState(0);
      const [opNextEst,setOpNextEst]=React.useState(0);
      const [dataset,setDataset]=React.useState([]);
      const [log,setLog]=React.useState("");
      const [search,setSearch]=React.useState("");

      const appendLog=s=>setLog(p=>`${p?p+"\n":""}${s}`);

      async function refreshPrice(){
        const tk=(ticker||"").trim(); if(!tk){ appendLog("ticker が空です"); return; }
        const {price:px}=await fetchQuoteRobust(tk);
        if(px!=null){ setPrice(px); }
      }

      function fillFromRow(row, doFetch=false){
        setName(row.name||""); setTicker(row.ticker||""); setIndustry(row.industry||"");
        setOp(asArr(row.op)); setFcf(asArr(row.fcf)); setRoe(asArr(row.roe));
        setSharesOku(Number(row.sharesOku)||0);
        setOpNowEst(Number(row.opNowEst)||0); setOpNextEst(Number(row.opNextEst)||0);
        if(Number(row.price)) setPrice(Number(row.price));
        setPer(Number.isFinite(row.per)? row.per : null);
        setPbr(Number.isFinite(row.pbr)? row.pbr : null);
        if(doFetch && row.ticker) refreshPrice();
      }

      React.useEffect(()=>{ if((ticker||"").trim()) refreshPrice(); },[ticker]);
      React.useEffect(()=>{ (async()=>{ try{
          const override=getOverrideDataURL();
          await loadDatasetFromURL(override, years, setDataset, appendLog, fillFromRow);
        }catch(err){
          appendLog("初期ロード失敗: "+(err && err.message? err.message:err));
          appendLog("→ ?data= でURLを指定してください。");
        }})(); },[]);

      const cohort=React.useMemo(()=>{
        if(!dataset.length) return null;
        const slopeDivs=dataset.map(r=>{ const lr=linreg(r.op); const m=Math.max(1e-9,mean(r.op)); return lr.slope/m; });
        const seDivs=dataset.map(r=>{ const lr=linreg(r.op); const m=Math.max(1e-9,mean(r.op)); return lr.se/m; });
        const invs=seDivs.map(x=>1/Math.max(1e-9,x));
        const muSlope=mean(slopeDivs), sdSlope=Math.max(1e-9,stdev(slopeDivs));
        const muSe=mean(seDivs), sdSe=Math.max(1e-9,stdev(seDivs));
        const min1=Math.min(...slopeDivs), max1=Math.max(...slopeDivs);
        const min2=Math.min(...invs),      max2=Math.max(...invs);
        const medSlope=median(slopeDivs), madSlope=mad(slopeDivs);
        const medSe=median(seDivs),       madSe=mad(seDivs);
        const slopeSorted=slopeDivs.slice().sort((x,y)=>x-y);
        const seSorted=seDivs.slice().sort((x,y)=>x-y);
        return {muSlope,sdSlope,muSe,sdSe,min1,max1,min2,max2, medSlope,madSlope,medSe,madSe, slopeSorted,seSorted};
      },[dataset]);

      const roeSlopeCohort=React.useMemo(()=>{
        if(!dataset.length) return null;
        const slopes=dataset.map(r=>asArr(r.roe).filter(Number.isFinite)).map(a=>(a.length>=2? linreg(a).slope : null)).filter(x=>Number.isFinite(x));
        if(!slopes.length) return null;
        const mu=slopes.reduce((s,v)=>s+v,0)/slopes.length;
        const sd=Math.max(1e-9,stdev(slopes));
        return {mu,sd};
      },[dataset]);

      const calc=React.useMemo(()=>{
        const lr=linreg(op), mOP=Math.max(1e-9,mean(op));
        const slopeDiv=lr.slope/mOP, seDiv=lr.se/mOP;

        let growthScore=50, breScore=50;
        if(cohort){
          const mm1=(slopeDiv-cohort.min1)/Math.max(1e-9,cohort.max1-cohort.min1);
          const inv=1/Math.max(1e-9,seDiv);
          const mm2=(inv-cohort.min2)/Math.max(1e-9,cohort.max2-cohort.min2);
          growthScore=clamp(mm1*100,0,100);
          breScore   =clamp(mm2*100,0,100);
        }
        const opTrendScore=((growthScore+breScore)/2)*0.05;
        const fundGenScore=asArr(fcf).filter(x=>(Number(x)||0)>0).length;

        const {mu:roeMu, sd:roeSd}=roeSlopeCohort ?? {mu:0, sd:1e-9};
        const roeArr=asArr(roe).filter(Number.isFinite);
        const lastRoe=Number.isFinite(roeArr[roeArr.length-1])? roeArr[roeArr.length-1]:0;
        const lastRoeScore=6/(1+Math.exp(-25*(lastRoe-12)/12));
        const slope=roeArr.length>=2? linreg(roeArr).slope:0;
        const z=(slope-roeMu)/Math.max(1e-9,roeSd);
        const roeGrowthScore=Math.tanh(z);
        const barrierScore=lastRoeScore+roeGrowthScore;

        const investScore=opTrendScore+fundGenScore+barrierScore;

        let r=0.07,gN=0.025;
        if(cohort){
          const seStd   = zRobust(seDiv,    cohort.medSe,    cohort.madSe,    cohort.seSorted);
          const slopeStd= zRobust(slopeDiv, cohort.medSlope, cohort.madSlope, cohort.slopeSorted);
          const kr=1.0, kg=0.7;
          r = smoothLogistic(seStd,   7.0, 3.0, kr)/100;
          gN= smoothLogistic(slopeStd,2.5, 2.5,kg)/100;
        }

        const lastActual=Number(op[4])||0;
        const nowEst=Number(opNowEst)||0;
        const nextEst=Number(opNextEst)||0;
        let g=0;
        if(nextEst>0 && lastActual>0) g=Math.sqrt(nextEst/lastActual)-1;
        else if(nowEst>0 && lastActual>0) g=(nowEst/lastActual)-1;

        const op5=lastActual*Math.pow(1+g,5);
        const ni5=0.65*op5;
        const denom=Math.max(1e-6,r-gN);
        const tv5=ni5*(1+gN)/denom;
        const pv =tv5/Math.pow(1+r,5);
        const target=(Number(sharesOku)||0)>0? pv/Number(sharesOku):0;

        const ratio=price>0? target/price:0;
        const valVerdict= ratio>1.5 ? "great" : ratio>1 ? "neu" : "sell";
        const valLabel  = ratio>1.5 ? "買い"   : ratio>1 ? "中立" : "売り";

        const undervalPct = Number.isFinite(target) && price>0 ? (target/price-1)*100 : 0;

        return {opTrendScore,fundGenScore,barrierScore,investScore,r,gN,target,valVerdict,valLabel,undervalPct};
      },[op,fcf,roe,sharesOku,price,cohort,opNowEst,opNextEst,roeSlopeCohort]);

      function onSearchChange(v){ setSearch(v); const key=v.trim().toLowerCase(); if(!key) return; const hit=dataset.find(r=> r.name.toLowerCase().includes(key)|| r.ticker.toLowerCase().includes(key)); if(hit) fillFromRow(hit,false); }
      function onSearchEnter(e){ if(e.key!=="Enter") return; const key=search.trim().toLowerCase(); const hit=dataset.find(r=> r.name.toLowerCase().includes(key)|| r.ticker.toLowerCase().includes(key)); if(hit) fillFromRow(hit,true); }

      function scoreRow(row){
        const lr=linreg(row.op), mOP=Math.max(1e-9,mean(row.op));
        const slopeDiv=lr.slope/mOP, seDiv=lr.se/mOP;
        let growthScore=50, breScore=50, opTrendScore=0;
        if(cohort){
          const mm1=(slopeDiv-cohort.min1)/Math.max(1e-9,cohort.max1-cohort.min1);
          const inv=1/Math.max(1e-9,seDiv);
          const mm2=(inv-cohort.min2)/Math.max(1e-9,cohort.max2-cohort.min2);
          growthScore=clamp(mm1*100,0,100);
          breScore   =clamp(mm2*100,0,100);
          opTrendScore=((growthScore+breScore)/2)*0.05;
        }
        const {mu:roeMu, sd:roeSd}=roeSlopeCohort ?? {mu:0, sd:1e-9};
        const roePct=asArr(row.roe).filter(Number.isFinite);
        const lastRoe=Number.isFinite(roePct[4])? roePct[4]:0;
        const lastRoeScore=6/(1+Math.exp(-25*(lastRoe-12)/12));
        const slope=linreg(roePct).slope;
        const z=(slope-roeMu)/Math.max(1e-9,roeSd);
        const roeGrowthScore=Math.tanh(z);
        const barrierScore=lastRoeScore+roeGrowthScore;
        const fundGenScore=asArr(row.fcf).filter(x=>(Number(x)||0)>0).length;
        const investScore=opTrendScore+fundGenScore+barrierScore;

        let r=0.07,gN=0.025;
        if(cohort){
          const seStd = zRobust(seDiv,cohort.medSe,cohort.madSe,cohort.seSorted);
          const slopeStd=zRobust(slopeDiv,cohort.medSlope,cohort.madSlope,cohort.slopeSorted);
          const kr=1.2, kg=1.2;
          r=smoothLogistic(seStd,7.0,3.0,kr)/100;
          gN=smoothLogistic(slopeStd,2.5,2.5,kg)/100;
        }
        let label="",cls="";
        if(investScore<8){ label="売るべき企業"; cls="sell"; }
        else if(investScore<10){ label="様子見企業"; cls="neu"; }
        else if(investScore<12){ label="よい企業"; cls="good"; }
        else{ label="すばらしい企業"; cls="great"; }
        return {investScore,label,cls,r,gN};
      }

      const ranked=React.useMemo(()=> dataset.map(r=>({...r,_s:scoreRow(r)})).sort((a,b)=> b._s.investScore - a._s.investScore),[dataset,cohort,roeSlopeCohort]);
      const counts=React.useMemo(()=>{ let great=0,good=0; ranked.forEach(r=>{ if(r._s.label==="すばらしい企業") great++; else if(r._s.label==="よい企業") good++; }); return {great,good}; },[ranked]);

      const invLabel = calc.investScore<8?"売るべき企業":calc.investScore<10?"様子見企業":calc.investScore<12?"よい企業":"すばらしい企業";
      const activeURL = getOverrideDataURL() || (URL_JSDELIVR + "（失敗時 raw に自動フォールバック）");

      return h(React.Fragment,null,
        h("h1",null,"株式評価ミニ"),
        h("div",{className:"twocol"},
          h("div",null,
            /* 企業情報 */
            h("div",{className:"card",style:{marginBottom:16}},
              h("div",{className:"searchrow"},
                h("div",null,
                  h("div",{className:"label"},"会社名 / ティッカーを検索（入力でフォームへ反映、Enterで確定）"),
                  h("input",{value:search,placeholder:"例）トヨタ / 7203.T",onChange:e=>onSearchChange(e.target.value),onKeyDown:onSearchEnter})
                )
              ),
              h("div",{className:"row",style:{marginTop:10}},
                h("div",null, h("div",{className:"label"},"会社名"), h("input",{value:name,onChange:e=>setName(e.target.value)})),
                h("div",null, h("div",{className:"label"},"業種"), h("input",{value:industry,onChange:e=>setIndustry(e.target.value)}))
              ),
              h("div",{className:"row",style:{marginTop:10}},
                h("div",null, h("div",{className:"label"},"ティッカー"), h("input",{value:ticker,onChange:e=>setTicker(e.target.value)})),
                h("div",null, h("div",{className:"label"},"現在株価（円）"), h("input",{value:price,onChange:e=>setPrice(toNum(e.target.value)),inputMode:"decimal"}))
              ),
              h("div",{className:"row",style:{marginTop:10}},
                h("div",null, h("div",{className:"label"},"PER"), h("input",{value: per??"", onChange:e=>setPer(toNum(e.target.value)), inputMode:"decimal"})),
                h("div",null, h("div",{className:"label"},"PBR"), h("input",{value: pbr??"", onChange:e=>setPbr(toNum(e.target.value)), inputMode:"decimal"}))
              ),
              h("div",{className:"small",style:{marginTop:6}},"Data URL: ", activeURL)
            ),

            /* 企業評価・割安度評価（↑へ移動） */
            h("div",{className:"row",style:{marginBottom:16}},
              h("div",{className:"card"},
                h("div",{className:"headrow"},
                  h("h2",null,"企業評価"),
                  h("span",{className:"pill "+(invLabel==="すばらしい企業"?"great":invLabel==="よい企業"?"good":invLabel==="様子見企業"?"neu":"sell")}, invLabel)
                ),
                h("div",{style:{marginTop:8,fontSize:18}},
                  h("span",{className:"label"},"投資スコア"), " ",
                  h("span",{className:"headline"}, calc.investScore.toFixed(2))
                ),
                h("div",{className:"kpi",style:{marginTop:10}},
                  h("div",{className:"box"}, h("div",{className:"muted"},"利益推移"), h("div",null, h("b",null, Number(calc.opTrendScore).toFixed(2)))),
                  h("div",{className:"box"}, h("div",{className:"muted"},"資金創出"), h("div",null, h("b",null, Number(calc.fundGenScore).toFixed(2)))),
                  h("div",{className:"box"}, h("div",{className:"muted"},"参入障壁"), h("div",null, h("b",null, Number(calc.barrierScore).toFixed(2))))
                )
              ),
              h("div",{className:"card"},
                h("div",{className:"headrow"},
                  h("h2",null,"割安度評価"),
                  h("span",{className:"pill "+calc.valVerdict}, calc.valLabel)
                ),
                h("div",{style:{marginTop:8,fontSize:18}},
                  h("span",{className:"label"},"割安度スコア"), " ",
                  h("span",{className:"headline"}, prettyPct(calc.undervalPct))
                ),
                h("div",{className:"kpi",style:{marginTop:10}},
                  h("div",{className:"box"}, h("div",{className:"muted"},"期待収益率 r"), h("div",null, h("b",null, prettyPct(calc.r*100)))),
                  h("div",{className:"box"}, h("div",{className:"muted"},"成長率 gN"), h("div",null, h("b",null, prettyPct(calc.gN*100)))),
                  h("div",{className:"box"}, h("div",{className:"muted"},"目標株価"), h("div",null, h("b",null, pretty(calc.target))))
                )
              )
            ),

            /* コンセンサス予想（↓へ移動） */
            h("div",{className:"card",style:{marginBottom:16}},
              h("div",{className:"label"},"OP（前期/今期/来期 予想）"),
              h("div",{className:"row3"},
                h("div",null, h("div",{className:"label"},"前期OP（億円）"), h("input",{className:"disabled",value:(op[4]||0),disabled:true})),
                h("div",null, h("div",{className:"label"},"今期OP予想（億円）"), h("input",{value:opNowEst,onChange:e=>setOpNowEst(toNum(e.target.value)),inputMode:"decimal"})),
                h("div",null, h("div",{className:"label"},"来期OP予想（億円）"), h("input",{value:opNextEst,onChange:e=>setOpNextEst(toNum(e.target.value)),inputMode:"decimal"}))
              )
            ),
            
            /* ヒストリカルデータ（↓へ移動） */
            h("div",{className:"card",style:{marginBottom:16}},
              h("div",{className:"label"},"過去5年 営業利益（億円）"),
              h("div",{className:"grid5-head"}, [2021,2022,2023,2024,2025].map(y=>h("div",{key:y},y))),
              h("div",{className:"grid5"}, [0,1,2,3,4].map(i=>h("input",{key:i,value:op[i]||0,onChange:e=>setOp(op.map((x,j)=>j===i?toNum(e.target.value):x)),inputMode:"decimal"}))),
              h("div",{className:"label",style:{marginTop:12}},"過去5年 FCF（億円）"),
              h("div",{className:"grid5-head"}, [2021,2022,2023,2024,2025].map(y=>h("div",{key:y},y))),
              h("div",{className:"grid5"}, [0,1,2,3,4].map(i=>h("input",{key:i,value:fcf[i]||0,onChange:e=>setFcf(fcf.map((x,j)=>j===i?toNum(e.target.value):x)),inputMode:"decimal"}))),
              h("div",{className:"label",style:{marginTop:12}},"過去5年 ROE（%）"),
              h("div",{className:"grid5-head"}, [2021,2022,2023,2024,2025].map(y=>h("div",{key:y},y))),
              h("div",{className:"grid5"}, [0,1,2,3,4].map(i=>h("input",{key:i,value:Number.isFinite(roe[i])?(Number(roe[i]).toFixed(2)+"%"):"",onChange:e=>setRoe(roe.map((x,j)=> j===i ? parsePercentCell(e.target.value) : x)),inputMode:"decimal"})))
            ),
          ),

          /* 右：スクリーナー */
          h("div",null,
            h("div",{className:"card"},
              h("div",{style:{display:"flex",justifyContent:"space-between",alignItems:"center",marginBottom:6}},
                h("div",{style:{fontWeight:700}},"スクリーナー（投資スコア順・全件表示）"),
                h("div",null, h("span",{className:"tag"},"すばらしい: "+counts.great)," ",h("span",{className:"tag"},"よい: "+counts.good))
              ),
              h("div",{className:"hdr"}, h("div",null,"会社名"), h("div",null,"ティッカー"), h("div",null,"投資スコア"), h("div",null,"評価")),
              h("div",{className:"list"},
                ranked.map(r=> h("div",{key:r.id,className:"rowitem",onClick:()=>fillFromRow(r,true),
                  title:`r=${prettyPct(r._s.r*100)} / gN=${prettyPct(r._s.gN*100)}（個別算出）\nクリックでフォームへ反映`},
                  h("div",null, h("div",null,r.name||"-"), h("div",{className:"muted"}, r.industry || "")),
                  h("div",null,r.ticker||"-"),
                  h("div",null,(r._s.investScore).toFixed(2)),
                  h("div",null, h("span",{className:"pill "+r._s.cls}, r._s.label))
                ))
              )
            )
          )
        )
      );
    }

    ReactDOM.createRoot(document.getElementById("app")).render(React.createElement(App));
  })();
  </script>
</body>
</html>













